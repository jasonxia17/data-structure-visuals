{"version":3,"sources":["TreeNode.tsx","EdgeInCreation.tsx","Edge.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["TreeNode","nodeID","nodeMap","changeData","onBackspace","handleSelectStub","currEdgeParent","currEdgeDir","createEdge","onMouseDown","xCoord","yCoord","nodeData","leftChildId","rightChildId","isValidChild","Object","values","every","constrainChildPos","isPositionValid","x1","y1","x2","y2","onClick","e","stopPropagation","className","tabIndex","onKeyDown","key","length","includes","cx","cy","r","x","y","EdgeInCreation","mousePos","Edge","parentID","childID","childX","childY","parentX","parentY","dir","vec","M","transformedVec","mathjs","constrainedVec","map","coord","Math","max","App","useState","setNodeMap","setCurrEdgeParent","setCurrEdgeDir","setMousePos","draggedNodeId","setDraggedNode","grabOffset","setGrabOffset","useEffect","data","URL","window","location","href","searchParams","get","JSON","parse","callback","document","addEventListener","removeEventListener","newData","edgeDir","onMouseMove","pageX","pageY","parNode","find","node","undefined","dx","dy","newNodeMap","stringify","getAllIdsinSubtree","subrootId","concat","forEach","id","onDoubleClick","currentTarget","target","newNode","currId","keys","parseInt","modifiedNode","assign","permalink","origin","pathname","encodeURIComponent","navigator","clipboard","writeText","Boolean","hostname","match","ReactDOM","render","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cc9415d6.chunk.js","sourcesContent":["import React, { Fragment } from 'react';\nimport { NodeMap, constrainChildPos } from './App';\n\ninterface Props {\n  nodeID: number;\n  nodeMap: NodeMap;\n  currEdgeParent: number | null;\n  currEdgeDir: \"left\" | \"right\";\n  changeData: (nodeID: number, newData: string) => void;\n  handleSelectStub: (nodeID: number, edgeDir: \"left\" | \"right\") => void;\n  /* Create edge with this node as child */\n  createEdge: () => void;\n  onMouseDown: (e: React.MouseEvent) => void;\n  onBackspace: () => void;\n}\n\nconst TreeNode: React.FC<Props> = (\n  { nodeID, nodeMap, changeData, onBackspace,\n    handleSelectStub, currEdgeParent, currEdgeDir, createEdge, onMouseDown }) => {\n\n  const { xCoord, yCoord, nodeData, leftChildId, rightChildId } = nodeMap[nodeID];\n\n  const isRoot = Object.values(nodeMap)\n    .every(({ leftChildId, rightChildId }) => leftChildId !== nodeID && rightChildId !== nodeID);\n\n  const isValidChild = isRoot && (currEdgeParent !== null) &&\n    constrainChildPos(xCoord, yCoord, nodeMap[currEdgeParent].xCoord,\n      nodeMap[currEdgeParent].yCoord, currEdgeDir).isPositionValid;\n\n  return (\n    // tabIndex enables onKeyPress event listener\n    <Fragment>\n      {/* left child stub, only draw the stub if the child hasn't already been created and\n          the user isn't trying to set that edge right now. */}\n      {leftChildId === null && !(currEdgeParent === nodeID && currEdgeDir === \"left\") &&\n        <line x1={xCoord} y1={yCoord} x2={xCoord - 50} y2={yCoord + 50}\n          onClick={e => { handleSelectStub(nodeID, \"left\"); e.stopPropagation() }} />\n      }\n\n      {/* right child stub */}\n      {rightChildId === null && !(currEdgeParent === nodeID && currEdgeDir === \"right\") &&\n        <line x1={xCoord} y1={yCoord} x2={xCoord + 50} y2={yCoord + 50}\n          onClick={e => { handleSelectStub(nodeID, \"right\"); e.stopPropagation() }} />}\n\n      <g className={isValidChild ? \"valid-child\" : \"\"} tabIndex={0}\n        onKeyDown={e => {\n          if (e.key === \"Backspace\") {\n            onBackspace();\n            return;\n          }\n\n          if (nodeData.length >= 4) {\n            return;\n          }\n\n          if (\"0123456789\".includes(e.key) ||\n            (e.key === \"-\" && nodeData.length === 0) ||\n            (e.key === \".\" && !nodeData.includes(\".\"))) {\n\n            changeData(nodeID, nodeData + e.key);\n          }\n        }}\n\n        onClick={() => {\n          if (isValidChild) {\n            createEdge()\n          }\n        }}\n        \n        onMouseDown={onMouseDown}>\n        <circle cx={xCoord} cy={yCoord} r={45} />\n        <text x={xCoord} y={yCoord}>{nodeData}</text>\n      </g>\n    </Fragment>\n  );\n}\n\nexport default TreeNode;\n","import React from 'react';\nimport { NodeMap, constrainChildPos } from './App';\n\ninterface Props {\n  nodeMap: NodeMap;\n  currEdgeParent: number | null;\n  currEdgeDir: \"left\" | \"right\";\n  mousePos: { x: number, y: number };\n}\n\nconst EdgeInCreation: React.FC<Props> = ({ nodeMap, currEdgeParent, currEdgeDir, mousePos }) => {\n  if (currEdgeParent === null) {\n    return null;\n  }\n\n  const { xCoord, yCoord } = nodeMap[currEdgeParent]\n  const { x, y } = constrainChildPos(mousePos.x, mousePos.y, xCoord, yCoord, currEdgeDir);\n\n  return (\n    <line\n      className=\"edge-in-creation\"\n      x1={nodeMap[currEdgeParent].xCoord} y1={nodeMap[currEdgeParent].yCoord}\n      x2={x} y2={y} />\n  );\n}\n\nexport default EdgeInCreation;\n","import React from 'react';\nimport { NodeMap } from './App';\n\ninterface Props {\n  nodeMap: NodeMap;\n  parentID: number;\n  childID: number;\n  onClick: () => void;\n}\n\nconst Edge: React.FC<Props> = ({ nodeMap, parentID, childID, onClick }) => {\n  return (\n    <line\n      className=\"edge\"\n      x1={nodeMap[parentID].xCoord} y1={nodeMap[parentID].yCoord}\n      x2={nodeMap[childID].xCoord} y2={nodeMap[childID].yCoord} \n      onClick={onClick}/>\n  );\n}\n\nexport default Edge;\n","import React, { useState, useEffect, Fragment } from 'react';\nimport * as mathjs from 'mathjs';\nimport TreeNode from './TreeNode';\nimport EdgeInCreation from './EdgeInCreation';\nimport Edge from './Edge';\nimport './App.css';\n\ninterface Node {\n  nodeData: string;\n  xCoord: number;\n  yCoord: number;\n  leftChildId: number | null;\n  rightChildId: number | null;\n}\n\nexport type NodeMap = { [key: number]: Node };\n\nexport const constrainChildPos = (childX: number, childY: number,\n  parentX: number, parentY: number, dir: \"left\" | \"right\") => {\n\n  const vec = [childX - parentX, childY - parentY]\n\n  const M = dir === \"left\" ? [\n    [-24 / 25, -7 / 25],\n    [7 / 25, 24 / 25],\n  ] : [\n      [24 / 25, 7 / 25],\n      [7 / 25, 24 / 25],\n    ];\n\n  const transformedVec = mathjs.multiply(mathjs.inv(M), vec) as number[];\n\n  let constrainedVec = transformedVec.map(coord => Math.max(coord, 0));\n  constrainedVec = mathjs.multiply(M, constrainedVec) as number[];\n  constrainedVec = mathjs.add(constrainedVec, [parentX, parentY]) as number[];\n\n  const isPositionValid = transformedVec.every(coord => coord > 0);\n\n  return { x: constrainedVec[0], y: constrainedVec[1], isPositionValid };\n}\n\nconst App: React.FC = () => {\n  const [nodeMap, setNodeMap] = useState({} as NodeMap);\n  const [currEdgeParent, setCurrEdgeParent] = useState(null as number | null);\n  const [currEdgeDir, setCurrEdgeDir] = useState(\"left\" as \"left\" | \"right\");\n  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n  const [draggedNodeId, setDraggedNode] = useState(null as number | null);\n  const [grabOffset, setGrabOffset] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const url = new URL(window.location.href);\n    const data = url.searchParams.get(\"data\");\n    if (data) {\n      setNodeMap(JSON.parse(data));\n    }\n  }, []) // empty array => componentDidMount, never update\n\n  useEffect(() => {\n    const callback = () => setDraggedNode(null);\n    document.addEventListener(\"mouseup\", callback);\n    return () => document.removeEventListener(\"mouseup\", callback);\n  }, [])\n\n  const createNewNode = (e: React.MouseEvent) => {\n    if (e.currentTarget !== e.target) {\n      return;\n    }\n\n    const newNode: Node = {\n      nodeData: \"\",\n      xCoord: e.pageX,\n      yCoord: e.pageY,\n      leftChildId: null,\n      rightChildId: null,\n    };\n\n    let currId = 0;\n    while (currId in nodeMap) {\n      ++currId;\n    }\n    setNodeMap({ ...nodeMap, [currId]: newNode });\n  }\n\n  const getAllIdsinSubtree = (subrootId: number | null): number[] => {\n    if (subrootId === null) {\n      return [];\n    }\n\n    return [subrootId]\n      .concat(getAllIdsinSubtree(nodeMap[subrootId].leftChildId))\n      .concat(getAllIdsinSubtree(nodeMap[subrootId].rightChildId))\n  }\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    setMousePos({ x: e.pageX, y: e.pageY });\n\n    if (draggedNodeId !== null) {\n      let x = e.pageX + grabOffset.x;\n      let y = e.pageY + grabOffset.y;\n\n      let parNode = Object.values(nodeMap).find(node =>\n        node.leftChildId === draggedNodeId || node.rightChildId === draggedNodeId);\n\n      if (parNode !== undefined) {\n        const dir = parNode.leftChildId === draggedNodeId ? \"left\" : \"right\";\n        ({ x, y } = constrainChildPos(x, y, parNode.xCoord, parNode.yCoord, dir));\n      }\n\n      const dx = x - nodeMap[draggedNodeId].xCoord;\n      const dy = y - nodeMap[draggedNodeId].yCoord;\n      const newNodeMap: NodeMap = JSON.parse(JSON.stringify(nodeMap));\n\n      getAllIdsinSubtree(draggedNodeId).forEach(id => {\n        newNodeMap[id].xCoord += dx;\n        newNodeMap[id].yCoord += dy;\n      })\n\n      setNodeMap(newNodeMap);\n    }\n  }\n\n  const changeData = (nodeID: number, newData: string) => {\n    setNodeMap({ ...nodeMap, [nodeID]: { ...nodeMap[nodeID], nodeData: newData } });\n  }\n\n  const handleSelectStub = (nodeID: number, edgeDir: \"left\" | \"right\") => {\n    setCurrEdgeParent(nodeID);\n    setCurrEdgeDir(edgeDir);\n  }\n\n  const copyPermalinkToClipboard = () => {\n    const permalink = window.location.origin + window.location.pathname +\n      \"?data=\" + encodeURIComponent(JSON.stringify(nodeMap));\n    navigator.clipboard.writeText(permalink);\n  }\n\n  let className = currEdgeParent === null ? \"no-edge-in-creation\" : \"edge-in-creation\";\n  className += \" wrapper\";\n  if (draggedNodeId !== null) {\n    className += \" drag-in-progress\";\n  }\n\n  return (\n    <div className={className}>\n      <svg\n        onMouseMove={handleMouseMove}\n        onDoubleClick={createNewNode}\n        onClick={() => setCurrEdgeParent(null)}\n      >\n\n        {Object.keys(nodeMap)\n          .map(nodeID => parseInt(nodeID))\n          .map(nodeID => {\n            const { leftChildId, rightChildId } = nodeMap[nodeID];\n            return (\n              <Fragment key={nodeID}>\n                {leftChildId !== null &&\n                  <Edge nodeMap={nodeMap} parentID={nodeID} childID={leftChildId}\n                    onClick={() =>\n                      setNodeMap({ ...nodeMap, [nodeID]: { ...nodeMap[nodeID], leftChildId: null } })}\n                  />}\n\n                {rightChildId !== null &&\n                  <Edge nodeMap={nodeMap} parentID={nodeID} childID={rightChildId}\n                    onClick={() =>\n                      setNodeMap({ ...nodeMap, [nodeID]: { ...nodeMap[nodeID], rightChildId: null } })}\n                  />}\n              </Fragment>\n            );\n          })}\n\n        <EdgeInCreation nodeMap={nodeMap} currEdgeParent={currEdgeParent}\n          currEdgeDir={currEdgeDir} mousePos={mousePos} />\n\n        {Object.keys(nodeMap)\n          .map(nodeID => parseInt(nodeID))\n          .map(nodeID =>\n            <TreeNode\n              key={nodeID}\n              nodeID={nodeID}\n              nodeMap={nodeMap}\n              currEdgeParent={currEdgeParent}\n              currEdgeDir={currEdgeDir}\n              changeData={changeData}\n              handleSelectStub={handleSelectStub}\n\n              onBackspace={() => {\n                const newNodeMap: NodeMap = JSON.parse(JSON.stringify(nodeMap));\n                delete newNodeMap[nodeID];\n                Object.values(newNodeMap).forEach(node => {\n                  if (node.leftChildId === nodeID) node.leftChildId = null;\n                  if (node.rightChildId === nodeID) node.rightChildId = null;\n                });\n\n                setNodeMap(newNodeMap);\n              }}\n\n              onMouseDown={e => {\n                if (currEdgeParent !== null) {\n                  return;\n                }\n\n                setDraggedNode(nodeID);\n                const x = nodeMap[nodeID].xCoord - e.pageX;\n                const y = nodeMap[nodeID].yCoord - e.pageY;\n                setGrabOffset({ x, y });\n              }}\n\n              createEdge={() => {\n                if (currEdgeParent === null) return;\n                const modifiedNode = { ...nodeMap[currEdgeParent] };\n                if (currEdgeDir === \"left\") {\n                  Object.assign(modifiedNode, { leftChildId: nodeID })\n                } else {\n                  Object.assign(modifiedNode, { rightChildId: nodeID })\n                }\n\n                setNodeMap({ ...nodeMap, [currEdgeParent]: modifiedNode });\n              }}\n            />\n          )}\n      </svg>\n\n      <div className=\"sidebar\">\n        <h3>Binary Search / AVL Tree</h3>\n        <ul>\n          <li>Double-click anywhere to create a new node</li>\n          <li>Select a node and type to enter data</li>\n          <li>To delete a node, select it and hit BACKSPACE</li>\n          <li>To create an edge, click on one of the parent's stubs. Then, click the desired child.\n            (Child must be positioned properly relative to parent for edge to be created.)\n          </li>\n          <li>Click on an edge to delete it</li>\n          <li>Drag a node to move its entire subtree</li>\n        </ul>\n\n        <button onClick={copyPermalinkToClipboard}>Copy permalink to clipboard</button>\n        <button onClick={() =>\n          window.location.href = window.location.origin + window.location.pathname}>\n          Clear\n        </button>\n        <p className=\"author\"><i>Created by <a href=\"mailto:jasonx3@illinois.edu\">Jason Xia</a></i></p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}