{"version":3,"sources":["TreeNode.tsx","EdgeInCreation.tsx","Edge.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["TreeNode","nodeID","nodeMap","changeData","onDelete","handleSelectStub","currEdgeParent","currEdgeDir","createEdge","onMouseDown","xCoord","yCoord","nodeData","leftChildId","rightChildId","isValidChild","Object","values","every","x1","y1","x2","y2","onClick","e","stopPropagation","className","tabIndex","onKeyDown","key","length","includes","cx","cy","r","x","y","EdgeInCreation","mousePos","Edge","parentID","childID","constrainChildPos","childX","childY","parentX","parentY","dir","deltaX","deltaXSign","Math","max","positionSubtree","subrootId","dx","dy","getAllIdsinSubtree","concat","forEach","id","App","useState","setNodeMap","setCurrEdgeParent","setCurrEdgeDir","setMousePos","draggedNodeId","setDraggedNode","grabOffset","setGrabOffset","useEffect","data","URL","window","location","href","searchParams","get","JSON","parse","callback","document","addEventListener","removeEventListener","newData","edgeDir","onMouseMove","pageX","pageY","parNode","find","node","undefined","newNodeMap","stringify","onDoubleClick","currentTarget","target","newNode","currId","keys","map","parseInt","parentId","childId","childNode","targetX","targetY","requestAnimationFrame","animateCallback","sign","createNewEdge","permalink","origin","pathname","encodeURIComponent","navigator","clipboard","writeText","Boolean","hostname","match","ReactDOM","render","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e7a48716.chunk.js","sourcesContent":["import React, { Fragment } from 'react';\nimport { NodeMap } from './App';\n\ninterface Props {\n  nodeID: number;\n  nodeMap: NodeMap;\n  currEdgeParent: number | null;\n  currEdgeDir: \"left\" | \"right\";\n  changeData: (nodeID: number, newData: string) => void;\n  handleSelectStub: (nodeID: number, edgeDir: \"left\" | \"right\") => void;\n  /* Create edge with this node as child */\n  createEdge: () => void;\n  onMouseDown: (e: React.MouseEvent) => void;\n  onDelete: () => void;\n}\n\nconst TreeNode: React.FC<Props> = (\n  { nodeID, nodeMap, changeData, onDelete,\n    handleSelectStub, currEdgeParent, currEdgeDir, createEdge, onMouseDown }) => {\n\n  const { xCoord, yCoord, nodeData, leftChildId, rightChildId } = nodeMap[nodeID];\n\n  const isRoot = Object.values(nodeMap)\n    .every(({ leftChildId, rightChildId }) => leftChildId !== nodeID && rightChildId !== nodeID);\n\n  const isValidChild = isRoot;\n\n  return (\n    // tabIndex enables onKeyPress event listener\n    <Fragment>\n      {/* left child stub, only draw the stub if the child hasn't already been created and\n          the user isn't trying to set that edge right now. */}\n      {leftChildId === null && !(currEdgeParent === nodeID && currEdgeDir === \"left\") &&\n        <line x1={xCoord} y1={yCoord} x2={xCoord - 50} y2={yCoord + 50}\n          onClick={e => { handleSelectStub(nodeID, \"left\"); e.stopPropagation() }} />\n      }\n\n      {/* right child stub */}\n      {rightChildId === null && !(currEdgeParent === nodeID && currEdgeDir === \"right\") &&\n        <line x1={xCoord} y1={yCoord} x2={xCoord + 50} y2={yCoord + 50}\n          onClick={e => { handleSelectStub(nodeID, \"right\"); e.stopPropagation() }} />}\n\n      <g className={isValidChild ? \"valid-child\" : \"\"} tabIndex={0}\n        onKeyDown={e => {\n          if (e.key === \"Delete\") {\n            onDelete();\n            return;\n          }\n          if (e.key === \"Backspace\") {\n            changeData(nodeID, \"\");\n            return;\n          }\n          if (nodeData.length >= 4) {\n            return;\n          }\n          if (\"0123456789\".includes(e.key) ||\n            (e.key === \"-\" && nodeData.length === 0) ||\n            (e.key === \".\" && !nodeData.includes(\".\"))) {\n\n            changeData(nodeID, nodeData + e.key);\n          }\n        }}\n\n        onClick={() => {\n          if (isValidChild) {\n            createEdge()\n          }\n        }}\n        \n        onMouseDown={onMouseDown}>\n        <circle cx={xCoord} cy={yCoord} r={45} />\n        <text x={xCoord} y={yCoord}>{nodeData}</text>\n      </g>\n    </Fragment>\n  );\n}\n\nexport default TreeNode;\n","import React from 'react';\nimport { NodeMap } from './App';\n\ninterface Props {\n  nodeMap: NodeMap;\n  currEdgeParent: number | null;\n  currEdgeDir: \"left\" | \"right\";\n  mousePos: { x: number, y: number };\n}\n\nconst EdgeInCreation: React.FC<Props> = ({ nodeMap, currEdgeParent, mousePos }) => {\n  if (currEdgeParent === null) {\n    return null;\n  }\n\n  return (\n    <line\n      className=\"edge-in-creation\"\n      x1={nodeMap[currEdgeParent].xCoord} y1={nodeMap[currEdgeParent].yCoord}\n      x2={mousePos.x} y2={mousePos.y} />\n  );\n}\n\nexport default EdgeInCreation;\n","import React from 'react';\nimport { NodeMap } from './App';\n\ninterface Props {\n  nodeMap: NodeMap;\n  parentID: number;\n  childID: number;\n  onClick: () => void;\n}\n\nconst Edge: React.FC<Props> = ({ nodeMap, parentID, childID, onClick }) => {\n  return (\n    <line\n      className=\"edge\"\n      x1={nodeMap[parentID].xCoord} y1={nodeMap[parentID].yCoord}\n      x2={nodeMap[childID].xCoord} y2={nodeMap[childID].yCoord} \n      onClick={onClick}/>\n  );\n}\n\nexport default Edge;\n","import React, { useState, useEffect, Fragment } from 'react';\nimport TreeNode from './TreeNode';\nimport EdgeInCreation from './EdgeInCreation';\nimport Edge from './Edge';\nimport './App.css';\n\ninterface Node {\n  nodeData: string;\n  xCoord: number;\n  yCoord: number;\n  leftChildId: number | null;\n  rightChildId: number | null;\n}\n\nexport type NodeMap = { [key: number]: Node };\n\nexport const constrainChildPos = (childX: number, childY: number,\n  parentX: number, parentY: number, dir: \"left\" | \"right\") => {\n\n  let deltaX = childX - parentX;\n  const deltaXSign = dir === \"left\" ? -1 : 1;\n  deltaX *= deltaXSign;\n  deltaX = Math.max(60, deltaX);\n  deltaX *= deltaXSign;\n\n  return {\n    x: parentX + deltaX,\n    y: parentY + 125,\n  };\n}\n\nconst getAllIdsinSubtree = (subrootId: number | null, nodeMap: NodeMap): number[] => {\n  if (subrootId === null) {\n    return [];\n  }\n\n  return [subrootId]\n    .concat(getAllIdsinSubtree(nodeMap[subrootId].leftChildId, nodeMap))\n    .concat(getAllIdsinSubtree(nodeMap[subrootId].rightChildId, nodeMap))\n}\n\n/**\n * nodeMap is modified in place. \n */\nconst positionSubtree = (subrootId: number, x: number, y: number, nodeMap: NodeMap) => {\n  const dx = x - nodeMap[subrootId].xCoord;\n  const dy = y - nodeMap[subrootId].yCoord;\n\n  getAllIdsinSubtree(subrootId, nodeMap).forEach(id => {\n    nodeMap[id].xCoord += dx;\n    nodeMap[id].yCoord += dy;\n  })\n}\n\nconst App: React.FC = () => {\n  const [nodeMap, setNodeMap] = useState({} as NodeMap);\n  const [currEdgeParent, setCurrEdgeParent] = useState(null as number | null);\n  const [currEdgeDir, setCurrEdgeDir] = useState(\"left\" as \"left\" | \"right\");\n  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n  const [draggedNodeId, setDraggedNode] = useState(null as number | null);\n  const [grabOffset, setGrabOffset] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const url = new URL(window.location.href);\n    const data = url.searchParams.get(\"data\");\n    if (data) {\n      setNodeMap(JSON.parse(data));\n    }\n  }, []) // empty array => componentDidMount, never update\n\n  useEffect(() => {\n    const callback = () => setDraggedNode(null);\n    document.addEventListener(\"mouseup\", callback);\n    return () => document.removeEventListener(\"mouseup\", callback);\n  }, [])\n\n  const createNewNode = (e: React.MouseEvent) => {\n    if (e.currentTarget !== e.target) {\n      return;\n    }\n\n    const newNode: Node = {\n      nodeData: \"\",\n      xCoord: e.pageX,\n      yCoord: e.pageY,\n      leftChildId: null,\n      rightChildId: null,\n    };\n\n    let currId = 0;\n    while (currId in nodeMap) {\n      ++currId;\n    }\n    setNodeMap({ ...nodeMap, [currId]: newNode });\n  }\n\n  const createNewEdge = (parentId: number, childId: number) => {\n    const newNodeMap: NodeMap = JSON.parse(JSON.stringify(nodeMap));\n    if (currEdgeDir === \"left\") {\n      newNodeMap[parentId].leftChildId = childId;\n    } else {\n      newNodeMap[parentId].rightChildId = childId;\n    }\n    setNodeMap(JSON.parse(JSON.stringify(newNodeMap)));\n\n    const parNode = newNodeMap[parentId];\n    const childNode = newNodeMap[childId];\n    const { x : targetX, y : targetY } = constrainChildPos(childNode.xCoord, childNode.yCoord,\n      parNode.xCoord, parNode.yCoord, currEdgeDir);\n    \n    const animateCallback = () => {\n      const dx = targetX - childNode.xCoord;\n      const dy = targetY - childNode.yCoord;\n\n      if (dx === 0 && dy === 0) {\n        return;\n      }\n      \n      if (dx !== 0) {\n        positionSubtree(childId, childNode.xCoord + Math.sign(dx), childNode.yCoord, newNodeMap);\n      } else if (dy !== 0) {\n        positionSubtree(childId, childNode.xCoord, childNode.yCoord + Math.sign(dy), newNodeMap);\n      }\n\n      setNodeMap(JSON.parse(JSON.stringify(newNodeMap)));\n      window.requestAnimationFrame(animateCallback);\n    }\n    window.requestAnimationFrame(animateCallback);   \n  }\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    setMousePos({ x: e.pageX, y: e.pageY });\n\n    if (draggedNodeId !== null) {\n      let x = e.pageX + grabOffset.x;\n      let y = e.pageY + grabOffset.y;\n\n      let parNode = Object.values(nodeMap).find(node =>\n        node.leftChildId === draggedNodeId || node.rightChildId === draggedNodeId);\n\n      if (parNode !== undefined) {\n        const dir = parNode.leftChildId === draggedNodeId ? \"left\" : \"right\";\n        ({ x, y } = constrainChildPos(x, y, parNode.xCoord, parNode.yCoord, dir));\n      }\n\n      const newNodeMap = JSON.parse(JSON.stringify(nodeMap));\n      positionSubtree(draggedNodeId, x, y, newNodeMap);\n      setNodeMap(newNodeMap);\n    }\n  }\n\n  const changeData = (nodeID: number, newData: string) => {\n    setNodeMap({ ...nodeMap, [nodeID]: { ...nodeMap[nodeID], nodeData: newData } });\n  }\n\n  const handleSelectStub = (nodeID: number, edgeDir: \"left\" | \"right\") => {\n    setCurrEdgeParent(nodeID);\n    setCurrEdgeDir(edgeDir);\n  }\n\n  const copyPermalinkToClipboard = () => {\n    const permalink = window.location.origin + window.location.pathname +\n      \"?data=\" + encodeURIComponent(JSON.stringify(nodeMap));\n    navigator.clipboard.writeText(permalink);\n  }\n\n  let className = currEdgeParent === null ? \"no-edge-in-creation\" : \"edge-in-creation\";\n  className += \" wrapper\";\n  if (draggedNodeId !== null) {\n    className += \" drag-in-progress\";\n  }\n\n  return (\n    <div className={className}>\n      <svg\n        onMouseMove={handleMouseMove}\n        onDoubleClick={createNewNode}\n        onClick={() => setCurrEdgeParent(null)}\n      >\n\n        {Object.keys(nodeMap)\n          .map(nodeID => parseInt(nodeID))\n          .map(nodeID => {\n            const { leftChildId, rightChildId } = nodeMap[nodeID];\n            return (\n              <Fragment key={nodeID}>\n                {leftChildId !== null &&\n                  <Edge nodeMap={nodeMap} parentID={nodeID} childID={leftChildId}\n                    onClick={() =>\n                      setNodeMap({ ...nodeMap, [nodeID]: { ...nodeMap[nodeID], leftChildId: null } })}\n                  />}\n\n                {rightChildId !== null &&\n                  <Edge nodeMap={nodeMap} parentID={nodeID} childID={rightChildId}\n                    onClick={() =>\n                      setNodeMap({ ...nodeMap, [nodeID]: { ...nodeMap[nodeID], rightChildId: null } })}\n                  />}\n              </Fragment>\n            );\n          })}\n\n        <EdgeInCreation nodeMap={nodeMap} currEdgeParent={currEdgeParent}\n          currEdgeDir={currEdgeDir} mousePos={mousePos} />\n\n        {Object.keys(nodeMap)\n          .map(nodeID => parseInt(nodeID))\n          .map(nodeID =>\n            <TreeNode\n              key={nodeID}\n              nodeID={nodeID}\n              nodeMap={nodeMap}\n              currEdgeParent={currEdgeParent}\n              currEdgeDir={currEdgeDir}\n              changeData={changeData}\n              handleSelectStub={handleSelectStub}\n\n              onDelete={() => {\n                const newNodeMap: NodeMap = JSON.parse(JSON.stringify(nodeMap));\n                delete newNodeMap[nodeID];\n                Object.values(newNodeMap).forEach(node => {\n                  if (node.leftChildId === nodeID) node.leftChildId = null;\n                  if (node.rightChildId === nodeID) node.rightChildId = null;\n                });\n\n                setNodeMap(newNodeMap);\n              }}\n\n              onMouseDown={e => {\n                if (currEdgeParent !== null) {\n                  return;\n                }\n\n                setDraggedNode(nodeID);\n                const x = nodeMap[nodeID].xCoord - e.pageX;\n                const y = nodeMap[nodeID].yCoord - e.pageY;\n                setGrabOffset({ x, y });\n              }}\n\n              createEdge={() => {\n                if (currEdgeParent !== null) {\n                  createNewEdge(currEdgeParent, nodeID);\n                }\n              }}\n            />\n          )}\n      </svg>\n\n      <div className=\"sidebar\">\n        <h3>Binary Search / AVL Tree</h3>\n        <ul>\n          <li>Double-click anywhere to create a new node</li>\n          <li>Select a node and type to enter data, or BACKSPACE to clear the data</li>\n          <li>To delete a node, select it and hit DELETE</li>\n          <li>To create an edge, click on one of the parent's stubs. Then, click the desired child.</li>\n          <li>Click on an edge to delete it</li>\n          <li>Drag a node to move its entire subtree</li>\n        </ul>\n\n        <button onClick={copyPermalinkToClipboard}>Copy permalink to clipboard</button>\n        <button onClick={() =>\n          window.location.href = window.location.origin + window.location.pathname}>\n          Clear\n        </button>\n        <p className=\"author\"><i>Created by <a href=\"mailto:jasonx3@illinois.edu\">Jason Xia</a></i></p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}